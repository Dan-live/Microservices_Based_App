# Microservices_Based_App
Lab_1
# Импортируем модули tkinter и time
from tkinter import *
import time

# Задаём размер пикселя
Pixel_Size = 3

# Создаём главное окно
root = Tk()
# Запрещаем изменять размер окна
root.resizable(False, False)
# Устанавливаем заголовок окна
root.title("Горбик Данііл КВ-13")
# Получаем ширину и высоту экрана и центрируем окно
w = root.winfo_screenwidth()
h = root.winfo_screenheight()
w = w // 2
h = h // 2
w = w - 400
h = h - 300
# Устанавливаем размер окна
root.geometry('800x400+{}+{}'.format(w, h))
# Создаём холст (Canvas) для рисования
a = Canvas(root, width=800, height=365, bg='white')
a.pack()


# Функция `draw` принимает список координат `coords`, где каждая координата представляет собой пару (x, y).
# Она проходит по каждой координате в списке и создает на холсте прямоугольник, который представляет собой пиксель.
# Размеры прямоугольника задаются с учетом размера пикселя `Pixel_Size`.
# Цвет заполнения прямоугольника установлен на черный (fill="black").


# Функция `draw_bright` принимает список координат `coords`, где каждая координата представляет собой тройку (x, y, яркость).
# Она проходит по каждой координате в списке и создает на холсте прямоугольник, который представляет собой пиксель.
# Размеры прямоугольника задаются с учетом размера пикселя `Pixel_Size`.
# Цвет заполнения прямоугольника определяется в зависимости от значения `point[2]` (яркость).
# Если `point[2]` близко к 0, то используется светло-серый цвет с контуром того же цвета.
# В противном случае, цвет заполнения и контура прямоугольника выбирается в зависимости от значения `point[2]`.
# По умолчанию, если ни одно условие не выполняется, используется черный цвет.

# Функция `DDA` принимает координаты начальной точки (x1, y1) и конечной точки (x2, y2).
# Она использует алгоритм DDA для рисования линии между этими точками на холсте.

# Вычисляем разницу по координатам между начальной и конечной точкой
dx = abs(x2 - x1)
dy = abs(y2 - y1)

# Выбираем количество шагов (пикселей), которые необходимо нарисовать.
# Берем максимальное значение из dx и dy.
steps = dx if dx >= dy else dy

# Вычисляем приращения для x и y (dx и dy) для каждого шага.
dx = (x2 - x1) / steps
dy = (y2 - y1) / steps

# Инициализируем начальную позицию для x и y.
x, y = x1, y1

# Создаем список точек, начиная с начальной точки (x1, y1) и заканчивая конечной точкой (x2, y2).
points = [[x1, y1], [x2, y2]]

# В цикле проходим через каждый шаг и добавляем точки (координаты) в список.
for i in range(steps - 1):
    x += dx
    y += dy
    points.append([round(x), round(y)])

# Затем вызываем функцию `draw` для отображения линии на холсте, используя полученные точки.
draw(points)

# Функция `DDA_time` принимает начальные и конечные координаты (x1, y1, x2, y2) для рисования линии.
# Она также измеряет время выполнения алгоритма DDA и выводит результаты на экран.

# Вначале выводим разделительную строку для лучшей читаемости.
print("------------------------DDA-------------------------")

# Очищаем холст, удаляя все нарисованные ранее элементы.
a.delete("all")

# Засекаем текущее время перед вызовом функции Surname(1).
t1 = time.perf_counter()
Surname(1)

# Засекаем время после выполнения функции Surname(1) и выводим разницу времени как "DDA_Surname".
t2 = time.perf_counter()
print("DDA_Surname:", t2 - t1)

# Снова засекаем текущее время перед вызовом функции DDA для рисования линии.
t1 = time.perf_counter()
DDA(x1, y1, x2, y2)

# Засекаем время после выполнения функции DDA и выводим разницу времени как "DDA_line".
t2 = time.perf_counter()
print("DDA_line:", t2 - t1)


# Функция `Brezenhem_line` принимает начальные и конечные координаты (x1, y1, x2, y2) для рисования линии.
# Она использует алгоритм Брезенхема для рисования линии на холсте.

# Переменная `steep` определяет, является ли линия "крутой" (с большой разницей по y) или нет.
steep = abs(y2 - y1) > abs(x2 - x1)

# Если линия "крутая," меняем x и y местами в начальных и конечных координатах.
if steep:
    x1, y1 = y1, x1
    x2, y2 = y2, x2

# Если x1 больше x2, меняем местами x1 и x2, а также y1 и y2.
if x1 > x2:
    x1, x2 = x2, x1
    y1, y2 = y2, y1

# Вычисляем разницу между x-координатами начальной и конечной точек, а также между y-координатами.
dx = x2 - x1
dy = y2 - y1

# Инициализируем переменную `error` для учета ошибки и переменную `ystep` для определения направления по y.
error = int(dx / 2.0)
ystep = 1 if y1 < y2 else -1

# Инициализируем переменную `y` для текущей y-координаты.
y = y1

# Создаем список `points` для хранения координат точек на линии.
points = []

# В цикле проходим по x-координатам от x1 до x2 и добавляем соответствующие координаты (x, y) в список `points`.
for x in range(x1, x2 + 1):
    # В зависимости от значения `steep`, выбираем соответствующие координаты (x, y) или (y, x).
    coord = (y, x) if steep else (x, y)
    points.append(coord)

    # Уменьшаем значение `error` на абсолютное значение разницы по y.
    error -= abs(dy)

    # Если `error` становится отрицательным, изменяем текущую y-координату на `ystep`.
    if error < 0:
        y += ystep
        error += dx

# Затем вызываем функцию `draw` для отображения линии на холсте, используя полученные точки.
draw(points)


# Функция `Bresenhem_circle` принимает координаты центра окружности (x0, y0) и радиус окружности.

# Инициализируем начальные значения x и y.
x = 0
y = radius

# Инициализируем переменную delta, которая используется для вычисления ошибки.
delta = 1 - 2 * radius

# Инициализируем переменную error, которая также используется для учета ошибки.
error = 0

# Создаем пустой список `points` для хранения координат точек на окружности.
points = []

# В цикле выполняем алгоритм Брезенхема для определения координат точек на окружности.
while (y >= 0):
    # Добавляем четыре симметричные точки на окружности, используя значения x и y.
    points.append((x0 + x, y0 + y))
    points.append((x0 + x, y0 - y))
    points.append((x0 - x, y0 + y))
    points.append((x0 - x, y0 - y))

    # Вычисляем значение error для текущего состояния.
    error = 2 * (delta + y) - 1

    # Проверяем условия для изменения значений x и delta.
    if (delta < 0) and (error <= 0):
        x += 1
        delta += 2 * x + 1
        continue
    error = 2 * (delta - x) - 1
    if delta > 0 and error > 0:
        y -= 1
        delta += 1 - 2 * y
        continue

    # В остальных случаях изменяем значения x и delta.
    x += 1
    delta += 2 * (x - y)
    y -= 1

# Затем вызываем функцию `draw` для отображения точек на окружности на холсте.
draw(points)



# Функция `Wu` принимает начальные и конечные координаты (x1, y1, x2, y2) для рисования линии.

# Внутренняя функция `fpart` используется для определения дробной части числа.
def fpart(x):
    return x - int(x) if x > 0 else x - (int(x) + 1)

# Переменная `steep` определяет, является ли линия "крутой" (с большой разницей по y) или нет.
steep = abs(y2 - y1) > abs(x2 - x1)

# Если линия "крутая," меняем x и y местами в начальных и конечных координатах.
if steep:
    x1, y1 = y1, x1
    x2, y2 = y2, x2

# Если x1 больше x2, меняем местами x1 и x2, а также y1 и y2.
if x1 > x2:
    x1, x2 = x2, x1
    y1, y2 = y2, y1

# Вычисляем разницу между x-координатами начальной и конечной точек, а также между y-координатами.
dx = x2 - x1
dy = y2 - y1

# Вычисляем наклон линии (градиент) как отношение разницы по y к разнице по x.
if dx == 0:
    grad = 1
else:
    grad = dy / dx

# Инициализируем начальные значения для x-координат пикселей.
xpxl1 = x1
xpxl2 = x2

# Инициализируем переменную `interY` для хранения текущей y-координаты.
interY = y1

# Создаем пустой список `points` для хранения анти-алиасинг координат точек на линии.
points = []

# Основной цикл для рисования линии с анти-алиасингом.
if steep:
    for x in range(xpxl1, xpxl2):
        points.append([int(interY), x, fpart(interY)])
        points.append([int(interY) - 1, x, 1 - fpart(interY)])
        interY += grad
else:
    for x in range(xpxl1, xpxl2):
        points.append([x, int(interY), fpart(interY)])
        points.append([x, int(interY) - 1, 1 - fpart(interY)])
        interY += grad

# Вызываем функцию `draw_bright` для отображения анти-алиасинг линии на холсте, используя полученные точки.
draw_bright(points)



# Функция `Surname(n)` принимает параметр `n`, который определяет, какой алгоритм рисования использовать.

# Словарь `surname` содержит определенные буквы и их координаты для рисования.
# Каждая буква представлена в виде списка отрезков, заданных начальными и конечными точками.

# В зависимости от значения `n`, выбирается алгоритм рисования (DDA, Брезенхем или Wu).
# Затем для каждой буквы из словаря выполняется выбранный алгоритм рисования.

# Если `n` равно 1, используется DDA для рисования букв.
# Если `n` равно 2, используется алгоритм Брезенхема для рисования букв.
# В остальных случаях (n != 1 и n != 2), используется алгоритм Wu для рисования букв.



# Создается главный фрейм (mainFrame) с белым фоном.
mainFrame = Frame(root, bg="white")
mainFrame.pack()

# Создаются кнопки (dda_button, brezenhem_line_button, brezenhem_circle_button, Wu_button, clear_button) для взаимодействия с программой.
# Каждая кнопка имеет текстовое описание и связана с определенной функцией (DDA_time, Brezenhem_line_time, Bresenhem_circle_time, Wu_time, a.delete) через атрибут `command`.

# dda_button запускает DDA_time с заданными координатами при нажатии.
dda_button = Button(mainFrame, text="DDA", command=lambda: DDA_time(10, 75, 250, 77))

# brezenhem_line_button запускает Brezenhem_line_time с заданными координатами при нажатии.
brezenhem_line_button = Button(mainFrame, text="Brezenhem_line", command=lambda: Brezenhem_line_time(10, 75, 250, 77))

# brezenhem_circle_button запускает Bresenhem_circle_time с заданными координатами при нажатии.
brezenhem_circle_button = Button(mainFrame, text="Brezenhem_circle", command=lambda: Bresenhem_circle_time(135, 50, 40))

# Wu_button запускает Wu_time с заданными координатами при нажатии.
Wu_button = Button(mainFrame, text="Wu", command=lambda: Wu_time(10, 75, 250, 77))

# clear_button очищает холст, удаляя все отображенные объекты.
clear_button = Button(mainFrame, text="Clear", command=lambda: a.delete("all"))

# Расположение кнопок на фрейме в рядах и столбцах с использованием методов `grid`.
dda_button.grid(row=1, column=1)
brezenhem_line_button.grid(row=1, column=2)
brezenhem_circle_button.grid(row=1, column=3)
Wu_button.grid(row=1, column=4)
clear_button.grid(row=1, column=5)

# Запускается главный цикл программы для отображения интерфейса и обработки событий.
root.mainloop()
